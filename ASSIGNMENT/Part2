import random
import math
import matplotlib.pyplot as plt
from copy import deepcopy

class TSP:
    def __init__(self, towns, distances):
        self.towns = towns
        self.distances = distances
        self.num_towns = len(towns)
        
    def calculate_distance(self, route):
        total_distance = 0
        for i in range(len(route)):
            current_town = route[i]
            next_town = route[(i + 1) % len(route)]
            total_distance += self.distances[current_town][next_town]
        return total_distance
    
    def get_distance(self, town1, town2):
        return self.distances[town1][town2]

class SimulatedAnnealingSolver:
    def __init__(self, tsp, initial_temp=10000, cooling_rate=0.003, stopping_temp=0.1):
        self.tsp = tsp
        self.initial_temp = initial_temp
        self.cooling_rate = cooling_rate
        self.stopping_temp = stopping_temp
        self.current_temp = initial_temp
        self.best_route = None
        self.best_distance = float('inf')
        self.distance_history = []
        
    def generate_initial_route(self):
        route = list(range(self.tsp.num_towns))
        #route starts and ends with Windhoek (index 0)
        route.remove(0)
        random.shuffle(route)
        return [0] + route + [0]
    
    def generate_neighbor(self, route):
        new_route = deepcopy(route)
        #don't swap the first and last element (Windhoek)
        i, j = random.sample(range(1, len(new_route) - 1), 2)
        new_route[i], new_route[j] = new_route[j], new_route[i]
        return new_route
    
    def acceptance_probability(self, current_distance, new_distance):
        if new_distance < current_distance:
            return 1.0
        return math.exp((current_distance - new_distance) / self.current_temp)
    
    def cool(self):
        self.current_temp *= 1 - self.cooling_rate
    
    def solve(self):
        current_route = self.generate_initial_route()
        current_distance = self.tsp.calculate_distance(current_route)
        
        self.best_route = current_route
        self.best_distance = current_distance
        self.distance_history.append(current_distance)
        
        while self.current_temp > self.stopping_temp:
            new_route = self.generate_neighbor(current_route)
            new_distance = self.tsp.calculate_distance(new_route)
            
            if self.acceptance_probability(current_distance, new_distance) > random.random():
                current_route = new_route
                current_distance = new_distance
                
                if current_distance < self.best_distance:
                    self.best_route = current_route
                    self.best_distance = current_distance
                    
            self.distance_history.append(current_distance)
            self.cool()
            
        return self.best_route, self.best_distance
    
    def plot_history(self):
        plt.plot(self.distance_history)
        plt.xlabel('Iteration')
        plt.ylabel('Distance')
        plt.title('Simulated Annealing Convergence')
        plt.show()

def plot_route(tsp, route, town_names):
    #coordinates
    num_towns = len(town_names)
    angles = [n / float(num_towns) * 2 * math.pi for n in range(num_towns)]
    x = [math.cos(a) for a in angles]
    y = [math.sin(a) for a in angles]
    
    plt.figure(figsize=(8, 8))
    
    # plot towns
    for i, town in enumerate(town_names):
        plt.scatter(x[i], y[i], c='blue')
        plt.text(x[i], y[i] + 0.05, town, ha='center')
    
    #plot route
    route_x = [x[i] for i in route]
    route_y = [y[i] for i in route]
    plt.plot(route_x, route_y, 'r-')
    
    plt.title(f"TSP Route - Distance: {tsp.calculate_distance(route):.2f} km")
    plt.axis('equal')
    plt.show()

#example
if __name__ == "__main__":
    #town names & indices
    town_names = ["Windhoek", "Swakopmund", "Walvis Bay", "Otjiwarongo", "Tsumeb", 
                  "Groottontein", "Mariental", "Keetmanshoop", "Ondangwa", "Oshakati"]
    
    #distance matrix (indices correspond to town_names)
    distances = [
        [0, 361, 395, 249, 433, 459, 268, 497, 678, 712],
        [361, 0, 35.5, 379, 562, 589, 541, 859, 808, 779],
        [395, 35.5, 0, 413, 597, 623, 511, 732, 884, 855],
        [249, 379, 413, 0, 260, 183, 519, 768, 514, 485],
        [433, 562, 597, 260, 0, 60, 682, 921, 254, 288],
        [459, 589, 623, 183, 60, 0, 708, 947, 308, 342],
        [268, 541, 511, 519, 682, 708, 0, 231, 909, 981],
        [497, 859, 732, 768, 921, 947, 231, 0, 1175, 1210],
        [678, 808, 884, 514, 254, 308, 909, 1175, 0, 30],
        [712, 779, 855, 485, 288, 342, 981, 1210, 30, 0]
    ]
    
    tsp = TSP(town_names, distances)
    
    #initial random route
    initial_route = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
    print("Initial route:", [town_names[i] for i in initial_route])
    print("Initial distance:", tsp.calculate_distance(initial_route))
    
    #solve with simulated annealing
    solver = SimulatedAnnealingSolver(tsp, initial_temp=10000, cooling_rate=0.003)
    best_route, best_distance = solver.solve()
    
    print("\nOptimized route:", [town_names[i] for i in best_route])
    print("Optimized distance:", best_distance)
    
    #plot results
    solver.plot_history()
    plot_route(tsp, initial_route, town_names)
    plot_route(tsp, best_route, town_names)